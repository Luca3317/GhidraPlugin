package analysis;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.NotImplementedException;

import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighVariable;
import ghidra.program.model.pcode.PcodeBlockBasic;
import ghidra.program.model.pcode.PcodeOp;
import ghidra.program.model.pcode.PcodeOpAST;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public abstract class VulnerabilityDetectionAnalyzerComponent {

	protected List<Integer> equalInstr = Arrays.asList(PcodeOp.FLOAT_EQUAL, PcodeOp.INT_EQUAL);
	protected List<Integer> notEqualInstr = Arrays.asList(PcodeOp.FLOAT_NOTEQUAL, PcodeOp.INT_NOTEQUAL);
	protected List<Integer> lessInstrs = Arrays.asList(PcodeOp.INT_LESS, PcodeOp.INT_SLESS, PcodeOp.FLOAT_LESS);
	protected List<Integer> lessEqualInstrs = Arrays.asList(PcodeOp.INT_LESSEQUAL, PcodeOp.INT_SLESSEQUAL, PcodeOp.FLOAT_LESSEQUAL);	
	protected List<Integer> addInstrs = Arrays.asList(PcodeOp.INT_ADD, PcodeOp.FLOAT_ADD, PcodeOp.PTRADD);
	protected List<Integer> subInstrs = Arrays.asList(PcodeOp.INT_SUB, PcodeOp.FLOAT_SUB, PcodeOp.PTRSUB);
	protected List<Integer> multInstrs = Arrays.asList(PcodeOp.INT_MULT, PcodeOp.FLOAT_MULT);
	protected List<Integer> divInstrs = Arrays.asList(PcodeOp.INT_DIV, PcodeOp.FLOAT_DIV, PcodeOp.INT_SDIV);
	
	protected VulnerabilityDetectionResults results;
	
	protected EdgeCondition edgeCond = (func, src, dest, var, obj) -> { 
		throw new NotImplementedException
			("You need to reinitialize the edge condition before analysis is started (i.e. in the constructor)."); 
	};
	
	protected ReassignmentCondition reassCond = (block, var, obj, op) -> {
		throw new NotImplementedException
			("You need to reinitialize the reassignment condition before analysis is started (i.e. in the constructor)."); 
	};
	
	
	
	/**
	 * Perform the analysis. Unsure yet wether parameters are needed: refactor at very end
	 * @param program
	 * @param set
	 * @param monitor
	 * @param log
	 */
	public void analyze(Program program, TaskMonitor monitor, MessageLog log, boolean preferFalseNegatives) throws CancelledException {
						
		Set<HighFunction> hFuncs = VulnerabilityDetectionUtils.getHighFunctions(monitor, log);
		results = new VulnerabilityDetectionResults(getString());
		
		for (HighFunction highFunction : hFuncs)
			analyzeFunction(highFunction, monitor, log, preferFalseNegatives);
	}
	

	/**
	 * Returns {@code true} if operation is reachable under a given edge and a given reassignment condition, starting from the function entry point.
	 * Proxy method for {@link #reachableIf(PcodeOpAST, HighFunction, PcodeBlockBasic, HighVariable, Set, Object, boolean)}.
	 * @param op the operation that is tested for reachability
	 * @param func the function containing the operation. Needed for the edge condition check
	 * @param var the variable that is tested in the condition checks
	 * @param obj an additional object for any further needed items. Is passed to both the edge condition and the reassignment condition. Can be used, for example,
	 * to test multiple variables instead of just var
	 * @return {@code true} if operation is reachable under a given edge and a given reassignment condition, starting from the function entry point
	 */
	protected boolean reachableIf(PcodeOpAST op, HighFunction func, HighVariable var, Object obj) {
		return reachableIf(op, func, func.getBasicBlocks().get(0), var, obj, true, new HashMap<PcodeBlockBasic, Integer>(), new HashMap<PcodeBlockBasic, Integer>());
	}	

	int calcDepth = 4;
	protected boolean reachableIf(PcodeOpAST op, HighFunction func, PcodeBlockBasic block, HighVariable var, Object obj, boolean vuln, HashMap<PcodeBlockBasic, Integer> blocks, HashMap<PcodeBlockBasic, Integer> vulnBlocks) {
		
		int reass = reassCond.check(block, var, obj, op);
				
		if (reass == 1)
			vuln = true;
		else if (reass == -1)
			vuln = false;
		
		if (vuln && block.equals(op.getParent()))
			return true;
		
		if (reass == 10)
			vuln = true;
		else if (reass == -10)
			vuln = false;
		
		boolean vulnOut = false;
		PcodeBlockBasic out = null;
				
		for (int i = 0; i < block.getOutSize(); i++) {
			
			out = (PcodeBlockBasic) block.getOut(i);
			
			if (vuln) {
				vulnBlocks.put(out, vulnBlocks.keySet().contains(out) ? vulnBlocks.get(out) + 1 : 1);
				
				if (vulnBlocks.get(out) > calcDepth)
					continue;
			}
			else {
				blocks.put(out, blocks.keySet().contains(out) ? blocks.get(out) + 1 : 1);
				
				if (blocks.get(out) > calcDepth)
					continue;
			}
				
			if (reachableIf(op, func, out, var, obj, vuln && edgeCond.check(func, block, out, var, obj), blocks, vulnBlocks)) 
				return true;
		}
		
		return vulnOut;
	}

	

	protected abstract void analyzeFunction(HighFunction func, TaskMonitor monitor, MessageLog log, boolean preferFalseNegatives) throws CancelledException;
	
	public abstract String getString();
	
	public abstract String getDescription();
	
	public VulnerabilityDetectionResults getResults() {
		return results;
	}
}
