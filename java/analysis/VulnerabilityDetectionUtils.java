package analysis;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.decompiler.component.DecompilerUtils;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSet;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.InstructionIterator;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.DumbMemBufferImpl;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighSymbol;
import ghidra.program.model.pcode.HighVariable;
import ghidra.program.model.pcode.PcodeBlockBasic;
import ghidra.program.model.pcode.PcodeOp;
import ghidra.program.model.pcode.PcodeOpAST;
import ghidra.program.model.pcode.Varnode;
import ghidra.program.model.pcode.VarnodeAST;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public class VulnerabilityDetectionUtils {

	private static Program currentProgram;
	
	private static HashMap<HighVariable, LinkedHashSet<PcodeOpAST>> getDereferencingInstructions;
	private static HashMap<HighVariable, LinkedHashSet<PcodeOpAST>> getDirectlyDereferencingInstructions;
	
	private static HashMap<HighVariable, Integer> isPointer;
	private static Set<DecompileResults> getDecompileResults;
	
	private static HashMap<HighFunction, Set<HighVariable>> getParams;
	private static HashMap<HighFunction, Set<HighVariable>> getLocalVariables;
	
	
	public static void init(Program program) {
		
		if (currentProgram != null && currentProgram.equals(program))
			return;
		
		currentProgram = program;
		reset();
	}
	
	public static void reset() {
				
		getDereferencingInstructions = new HashMap<HighVariable, LinkedHashSet<PcodeOpAST>>();
		getDirectlyDereferencingInstructions = new HashMap<HighVariable, LinkedHashSet<PcodeOpAST>>();
		isPointer = new HashMap<HighVariable, Integer>();
		getDecompileResults = new LinkedHashSet<DecompileResults>();
		getParams = new HashMap<HighFunction, Set<HighVariable>>();
		getLocalVariables = new HashMap<HighFunction, Set<HighVariable>>();
	}
	
	
	//================================================================================
	// General dereferenciation
	//================================================================================
	
	/**
	 * Returns all Pcode instructions in which var is dereferenced.
	 * @param var the variable tested for dereferenciation
	 * @return all Pcode instructions in which var is dereferenced
	 */
	public static Set<PcodeOpAST> getDereferencingInstructions(HighVariable var) {
		
		if (getDereferencingInstructions.containsKey(var))
			return new LinkedHashSet<PcodeOpAST>(getDereferencingInstructions.get(var));
		
		LinkedHashSet<PcodeOpAST> set = new LinkedHashSet<PcodeOpAST>();
		List<PcodeOpAST> tmp = new ArrayList<PcodeOpAST>();
		
		for (PcodeBlockBasic pcbb : var.getHighFunction().getBasicBlocks()) {
			
			Iterator<PcodeOp> ops = pcbb.getIterator();
			
			while (ops.hasNext()) {
				
				PcodeOpAST op = (PcodeOpAST) ops.next();
				tmp.add(op);
				
				if ((op.getOpcode() == PcodeOp.LOAD || op.getOpcode() == PcodeOp.STORE) && isDereferenced(tmp, var))
					set.add(op);
				
				tmp.remove(op);
			}
		}
			
		getDereferencingInstructions.put(var, set);
		return new LinkedHashSet<PcodeOpAST>(getDereferencingInstructions.get(var));
	}
	
	/**
	 * Returns all dereferencing Pcode instructions contained in func.
	 * @param func 
	 * @return all dereferencing Pcode instructions contained in func
	 */
	public static Set<PcodeOpAST> getDereferencingInstructions(HighFunction func) {
		
		Set<PcodeOpAST> derefInstr = new LinkedHashSet<PcodeOpAST>();
		
		Set<HighVariable> vars = getLocalVariables(func);
		vars.addAll(getParameters(func));
		
		for (HighVariable var : vars)
			derefInstr.addAll(getDereferencingInstructions(var));
		
		return derefInstr;
	}
	
	/**
	 * Returns all basic blocks in which var is dereferenced.
	 * @param var
	 * @return
	 */
	public static Set<PcodeBlockBasic> getDereferencingBlocks(HighVariable var) {
		
		Set<PcodeBlockBasic> derefBlocks = new LinkedHashSet<PcodeBlockBasic>();
		
		for (PcodeOpAST op : getDereferencingInstructions(var))
			derefBlocks.add(op.getParent());
		
		return derefBlocks;
	}
	
	/**
	 * Returns all basic blocks in which a variable is dereferenced.
	 * @param var
	 * @return
	 */
	public static Set<PcodeBlockBasic> getDereferencingBlocks(HighFunction func) {
		
		Set<PcodeBlockBasic> derefBlocks = new LinkedHashSet<PcodeBlockBasic>();
		Iterator<HighSymbol> syms = func.getLocalSymbolMap().getSymbols();
		
		while (syms.hasNext()) {
			HighSymbol highSymbol = syms.next();
			
			for (PcodeOpAST op : getDereferencingInstructions(highSymbol.getHighVariable()))
				derefBlocks.add(op.getParent());
		}
		
		return derefBlocks;
	}
	
	/**
	 * Returns {@code true} if var is dereferenced within one or more of the Pcode instructions.
	 * @param pcodes the Pcode instructions that are to be checked for dereferenciation of var
	 * @param var the variable that is checked for dereferenciation
	 * @return {@code true} if var is dereferenced within one or more of the Pcode instructions
	 */
	public static boolean isDereferenced(List<PcodeOpAST> pcodes, HighVariable var) {

		Set<Varnode> nodes = DecompilerUtils.getForwardSlice(var.getRepresentative());
		return isDereferenced(pcodes, nodes);
	}
	
	/**
	 * Returns {@code true} if one or more of the varnodes is dereferenced within one or more of the Pcode instructions.
	 * @param pcodes the Pcode instructions that are to be checked for dereferenciation of the varnodes
	 * @param var the varnodes that is checked for dereferenciation
	 * @return {@code true} if one or more of the varnodes is dereferenced within one or more of the Pcode instructions
	 */
	public static boolean isDereferenced(List<PcodeOpAST> pcodes, Set<Varnode> nodes) {
		
		for (Varnode node : nodes) {
			
			if (!(node instanceof VarnodeAST)) {
				Msg.out("In GeneralUtils isDereferenced: Not originally VarnodeAST");
				continue;
			}
			
			VarnodeAST nodeAST = (VarnodeAST) node;

			for (PcodeOpAST pcode : pcodes) {
				
				if (pcode.getOpcode() != PcodeOp.LOAD && pcode.getOpcode() != PcodeOp.STORE)
					continue;
				
				VarnodeAST input = (VarnodeAST) pcode.getInput(1);
					
				if (input.getUniqueId() == nodeAST.getUniqueId())
					return true;
			}
		}
		
		return false;
	}

	/**
	 * Returns {@code true} if var is dereferenced.
	 * @param var
	 * @return
	 */
	public static boolean isDereferenced(HighVariable var) {
		return getDereferencingInstructions(var).size() > 0;
	}

	
	//================================================================================
	// Direct dereferenciation
	//================================================================================

	/**
	 * Returns all Pcode instructions that directly dereference (meaning without applying offset) var.
	 * @param var
	 * @return
	 */
	public static Set<PcodeOpAST> getDirectlyDereferencingInstructions(HighVariable var) {
		
		if (getDirectlyDereferencingInstructions.containsKey(var))
			return new LinkedHashSet<PcodeOpAST>(getDirectlyDereferencingInstructions.get(var));
		
		LinkedHashSet<PcodeOpAST> set = new LinkedHashSet<PcodeOpAST>();
		List<PcodeOpAST> tmp = new ArrayList<PcodeOpAST>();
		
		for (PcodeBlockBasic pcbb : var.getHighFunction().getBasicBlocks()) {
			
			Iterator<PcodeOp> ops = pcbb.getIterator();
			
			while (ops.hasNext()) {
				
				PcodeOpAST op = (PcodeOpAST) ops.next();
				tmp.add(op);
				
				if ((op.getOpcode() == PcodeOp.LOAD || op.getOpcode() == PcodeOp.STORE) && isDirectlyDereferenced(tmp, var))
					set.add(op);
				
				tmp.remove(op);
			}
		}
			
		getDirectlyDereferencingInstructions.put(var, set);
		return new LinkedHashSet<PcodeOpAST>(getDirectlyDereferencingInstructions.get(var));
	}
	
	/**
	 * Returns all directly dereferencing instructions contained in func.
	 * @param func
	 * @return
	 */
	public static Set<PcodeOpAST> getDirectlyDereferencingInstructions(HighFunction func) {
		
		Set<PcodeOpAST> derefInstr = new LinkedHashSet<PcodeOpAST>();
		
		Set<HighVariable> vars = getLocalVariables(func);
		vars.addAll(getParameters(func));
		
		for (HighVariable var : vars)
			derefInstr.addAll(getDirectlyDereferencingInstructions(var));
		
		return derefInstr;
	}
	
	/**
	 * Returns all basic blocks in which var is directly dereferenced.
	 * @param var
	 * @return
	 */
	public static Set<PcodeBlockBasic> getDirectlyDereferencingBlocks(HighVariable var) {
		
		Set<PcodeBlockBasic> derefBlocks = new LinkedHashSet<PcodeBlockBasic>();
		
		for (PcodeOpAST op : getDirectlyDereferencingInstructions(var))
			derefBlocks.add(op.getParent());
		
		return derefBlocks;
	}
	
	/**
	 * Returns all basic blocks in which a variable is directly dereferenced.
	 * @param var
	 * @return
	 */
	public static Set<PcodeBlockBasic> getDirectlyDereferencingBlocks(HighFunction func) {
		
		Set<PcodeBlockBasic> derefBlocks = new LinkedHashSet<PcodeBlockBasic>();
		Iterator<HighSymbol> syms = func.getLocalSymbolMap().getSymbols();
		
		while (syms.hasNext()) {
			HighSymbol highSymbol = syms.next();
			
			for (PcodeOpAST op : getDirectlyDereferencingInstructions(highSymbol.getHighVariable()))
				derefBlocks.add(op.getParent());
		}
		
		return derefBlocks;
	}
	
	/**
	 * Returns {@code true} if var is directly dereferenced within one or more of the Pcode instructions.
	 * @param pcodes the Pcode instructions that are to be checked for direct dereferenciation of var
	 * @param var the variable that is checked for direct dereferenciation
	 * @return {@code true} if var is directly dereferenced within one or more of the Pcode instructions
	 */
	public static boolean isDirectlyDereferenced(List<PcodeOpAST> pcodes, HighVariable var) {
	
		Set<Varnode> nodes = new LinkedHashSet<Varnode>(Arrays.asList(var.getInstances()));
		return isDereferenced(pcodes, nodes);
	}
	
	/**
	 * Returns {@code true} if var is directly dereferenced.
	 * @param var
	 * @return
	 */
	public static boolean isDirectlyDereferenced(HighVariable var) {
		return getDirectlyDereferencingInstructions(var).size() > 0;
	}
	
	
	//================================================================================
	// Pointer recognition
	//================================================================================
	
	/**
	 * Returns 1 if var is certainly a pointer, 0 if certainly not, -1 if neither could be inferred. 
	 * Proxy function for {@link #isPointer(HighVariable, List)}.
	 * @param var the variable that is checked for wether it is a pointer or not
	 * @return 1 if var is certainly a pointer, 0 if certainly not, -1 if neither could be inferred.
	 */
	public static int isPointer(HighVariable var) {		
			
		if (!isPointer.containsKey(var))
			isPointer.put(var, isPointer(var, new ArrayList<HighVariable>()));
	
		return isPointer.get(var);
	}

	/**
	 * Returns 1 if var is certainly a pointer, 0 if certainly not, -1 if neither could be inferred. 
	 * @param var the variable that is checked for wether it is a pointer or not
	 * @return 1 if var is certainly a pointer, 0 if certainly not, -1 if neither could be inferred.
	 */
	private static int isPointer(HighVariable var, List<HighVariable> testing) {
	
		if (isPointer.containsKey(var))
			return isPointer.get(var);
		
		// If this variable is already in the list, you need to return or endless loop
		if (testing.contains(var))
			return -1;
		
		testing.add(var);
		
		Memory mem = var.getHighFunction().getFunction().getProgram().getMemory();
		DumbMemBufferImpl buf = new DumbMemBufferImpl(mem, var.getHighFunction().getFunction().getEntryPoint());
			
		Object o = var.getDataType().getValue(buf, null, -1);
		
		int varIsPointer = -1;
		
		// If incorrect size, can not be a pointer
		if (var.getSize() != var.getHighFunction().getFunction().getProgram().getDefaultPointerSize())
			varIsPointer = 0;
	
		// if pointer datatype return 1
		else if (o instanceof Address)
			varIsPointer = 1;
		
		else if (isDirectlyDereferenced(var))
			varIsPointer = 1;

	//	else if (isMultiplied(var))
		//	varIsPointer = 0;
		else if (isMultiplied(var))
			varIsPointer = 0;
		
		else
			varIsPointer = isOnlyPossiblePointerinDeref(var, testing);
		
		return varIsPointer;
	}
		
	/**
	 * Returns {@code true} if var is multiplied.
	 * @param var
	 * @return
	 */
	private static boolean isMultiplied(HighVariable var) {
		
		HighFunction func = var.getHighFunction();
		Set<Varnode> nodes = DecompilerUtils.getForwardSlice(var.getRepresentative());

		List<VarnodeAST> nodesAST = new ArrayList<VarnodeAST>();
		
		for (Varnode node : nodes)
			nodesAST.add((VarnodeAST) node);
		
		Iterator<PcodeOpAST> ops = func.getPcodeOps();
		
		while (ops.hasNext()) {
			PcodeOpAST op = ops.next();
			
			if (!(op.getOpcode() == PcodeOp.FLOAT_MULT || op.getOpcode() == PcodeOp.INT_MULT)) 
				continue;

			VarnodeAST input0 = (VarnodeAST) op.getInput(0);
			VarnodeAST input1 = (VarnodeAST) op.getInput(1);
			
			if (nodesAST.contains(input0) || nodesAST.contains(input1))
				return true;
		}
		
		return false;
	}
	
	/**
	 * Returns 1 if var is only possible pointer in one of its dereferenciations, 
	 * 0 if it only serves as offset to another pointer, 
	 * -1 if nothing about var could be inferred.
	 * @param var
	 * @param testing
	 * @return
	 */
	private static int isOnlyPossiblePointerinDeref(HighVariable var, List<HighVariable> testing) {
		
		// Get all instructions that dereference var
		Set<PcodeOpAST> instructions = getDereferencingInstructions(var);
		
		// Get all variables in function
		Iterator<HighSymbol> syms = var.getHighFunction().getLocalSymbolMap().getSymbols();
		
		HighSymbol sym;
		
		// For all instructions that dereference var
		for (PcodeOpAST instr : instructions) {
			
			// Get all other varnodes (and thus variables) that are dereferenciated along with var (so either var or other variable(s) serve as offset or base)
			Set<Varnode> ancestors = DecompilerUtils.getBackwardSlice(instr.getInput(1));
			
			boolean allSymsNotPointer = true;
			
			// For all variables in function
			while (syms.hasNext()) {
				
				sym = syms.next();
				
				// If sym is var, no checking necessary
				if (sym.getHighVariable().equals(var))
					continue;
				
				// Check if sym is dereferenced along with var
				if (ancestors.contains(sym.getHighVariable().getRepresentative())) {
					
					int isPointerl = isPointer(sym.getHighVariable(), testing);
					
					// If sym is guaranteed to be a pointer, var can only be offset
					if (isPointerl == 1)
						return 0;
					
					// If sym could be either, nothing about var is implied
					if (isPointerl == -1) {
						allSymsNotPointer = false;
						break;
					}
					
					// If sym is guaranteed to not be a pointer, nothing about var is implied	
					// but if ALL sym != var are guaranteed to not be a pointer, then var is pointer
				}	
			}
			
			// If all sym != var not pointer, then var must be pointer
			if (allSymsNotPointer)
				return 1;
		}
		
		// If none of the return cases above apply, nothing about var could be inferred
		return -1;
	}

	
	//================================================================================
	// Function data
	//================================================================================
	
	/**
	 * Returns all high functions ( = decompiled functions) contained in the currently opened program.
	 * @param monitor
	 * @param log
	 * @return
	 * @throws CancelledException
	 */
	public static Set<DecompileResults> getDecompileResults(TaskMonitor monitor, MessageLog log) throws CancelledException {
		
		if (getDecompileResults.size() > 0)
			return new LinkedHashSet<DecompileResults>(getDecompileResults);
		
		LinkedHashSet<DecompileResults> decompRes = new LinkedHashSet<DecompileResults>();
		
		DecompInterface dif = new DecompInterface();
		dif.openProgram(currentProgram);
		
		FunctionManager funcMan = currentProgram.getFunctionManager();
		for (Function func : funcMan.getFunctions(true)) {
			
			DecompileResults dr = dif.decompileFunction(func, 100, monitor);
			
			if (monitor.isCancelled())
				monitor.checkCanceled();
			
			if (!dr.decompileCompleted()) {
				log.error("Vulnerability Detection Analyzer", "Failed to decompile " + func.getName() + ". It will not be analyzed.");
				continue;
			}
						
			decompRes.add(dr);
		}
		
		getDecompileResults = decompRes;
		return new LinkedHashSet<DecompileResults>(getDecompileResults);
	}
	
	public static Set<HighFunction> getHighFunctions(TaskMonitor monitor, MessageLog log) throws CancelledException {
		
		LinkedHashSet<HighFunction> hFuncs = new LinkedHashSet<HighFunction>();
		
		for (DecompileResults dr : getDecompileResults(monitor, log))
			hFuncs.add(dr.getHighFunction());
		
		return hFuncs;
	}
	

	/**
	 * Returns all locally declared variables (meaning excluding parameters) contained in func.
	 * @param func
	 * @return
	 */
	public static Set<HighVariable> getLocalVariables(HighFunction func) {
		
		if (getLocalVariables.containsKey(func))
			return new HashSet<HighVariable>(getLocalVariables.get(func));
		
		Set<HighVariable> locals = new LinkedHashSet<HighVariable>();

		Iterator<HighSymbol> symbs = func.getLocalSymbolMap().getSymbols();
		while (symbs.hasNext())
			locals.add(symbs.next().getHighVariable());
		
		Set<HighVariable> params = getParameters(func);
		
		for (HighVariable param : params)
			locals.remove(param);
		
		getLocalVariables.put(func, locals);
		return new LinkedHashSet<HighVariable>(getLocalVariables.get(func));
	}
	
	/**
	 * Returns all parameters that func receives.
	 * @param func
	 * @return
	 */
	public static Set<HighVariable> getParameters(HighFunction func) {

		if (getParams.containsKey(func))
			return new HashSet<HighVariable>(getParams.get(func));
		
		Set<HighVariable> params = new LinkedHashSet<HighVariable>();
		
		for (int i = 0; i < func.getLocalSymbolMap().getNumParams(); i++)
			params.add(func.getLocalSymbolMap().getParam(i));

		getParams.put(func, params);
		return new LinkedHashSet<HighVariable>(getParams.get(func));
	}

	
	//================================================================================
	// Other
	//================================================================================
	
	/**
	 * Returns all variables that make up the current value of the varnode.
	 * Might be improvable.
	 * @param func
	 * @param vna
	 * @return
	 */
	public static Set<HighVariable> getContainedVars(HighFunction func, VarnodeAST vna) {
		
		Set<HighVariable> set = new LinkedHashSet<HighVariable>();
		Set<Varnode> nodes = DecompilerUtils.getBackwardSlice(vna);
		
		for (Varnode node : nodes) {
			if (((VarnodeAST) node).getHigh() != null && ((VarnodeAST) node).getHigh().getName() != null)
				set.add(((VarnodeAST) node).getHigh());
		}
			
		return set;
	}
	
	/**
	 * Filters a list of Pcode instructions, removing all whose opcode is not contained in the filter list.
	 * For example, a filter declared as Arrays.asList(PcodeOp.LOAD, PcodeOp.STORE) will return all Pcode instructions 
	 * that are either LOAD or STORE instructions.
	 * @param ops
	 * @param filter
	 * @return
	 */
	public static List<PcodeOpAST> filterPcodeInstructions(List<PcodeOpAST> ops, List<Integer> filter) {
		
		List<PcodeOpAST> filtered = new ArrayList<PcodeOpAST>();
		
		for (PcodeOpAST op : ops)
			if (filter.contains(op.getOpcode()))
				filtered.add(op);
		
		return filtered;
	}
	
	/**
	 * Return all Pcode instructions contained in the given function.
	 * These are not necessarily in the right order.
	 * @param func
	 * @return
	 */
	public static List<PcodeOpAST> getInstructions(HighFunction func) {
		
		List<PcodeOpAST> ops = new ArrayList<PcodeOpAST>();
		
		for (PcodeBlockBasic block : func.getBasicBlocks()) {
			
			Iterator<PcodeOp> opsIt = block.getIterator();
			while (opsIt.hasNext()) {
				PcodeOpAST pcodeOp = (PcodeOpAST) opsIt.next();
				ops.add(pcodeOp);
			}		
		}
		
		return ops;
	}
	
	public static Address getAddress(PcodeOp op) {
		
		if (currentProgram == null)
			throw new IllegalStateException("VulnerabilityDetectionUtils has not yet been correctly initialized!");
		
		Listing list = currentProgram.getListing();
		InstructionIterator ii = list.getInstructions(new AddressSet(op.getParent().getStart(),  op.getParent().getStop()), true);
		
		while (ii.hasNext()) {
			Instruction instruction = ii.next();
			
			for (PcodeOp curOp : instruction.getPcode(true)) {
				if (curOp.equals(op))
					return instruction.getAddress();
			}
		}
		
		Msg.out("returning block addr");
		return op.getParent().getStart();
	}
	
		
	//================================================================================
	// Remove again
	//================================================================================
	
	public static void printBlocks(HighFunction func) {
		Msg.out(func.getFunction().getName());
		
		List<PcodeBlockBasic> pcbbs = func.getBasicBlocks();
		for (PcodeBlockBasic pcodeBlockBasic : pcbbs) {
			Msg.out("\n" + pcodeBlockBasic.getStart());
			
			Iterator<PcodeOp> ops = pcodeBlockBasic.getIterator();
			while (ops.hasNext()) {
				PcodeOp pcodeOp = ops.next();
				
				Msg.out(pcodeOp);
			}
			
			String out = "Flows into:";
			for (int i = 0; i < pcodeBlockBasic.getOutSize(); i++)
				out += "\t" + pcodeBlockBasic.getOut(i).getStart();
			
			Msg.out(out);
		}
		
		Msg.out("\n\n\n");
	}
}
