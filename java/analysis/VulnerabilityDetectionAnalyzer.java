package analysis;

import java.util.LinkedHashSet;
import java.util.Set;

import ghidra.app.services.AbstractAnalyzer;
import ghidra.app.services.AnalyzerType;
import ghidra.app.util.importer.MessageLog;
import ghidra.framework.options.Options;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.program.model.pcode.HighFunction;
import ghidra.program.model.pcode.HighVariable;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;

public class VulnerabilityDetectionAnalyzer extends AbstractAnalyzer {

	private Set<VulnerabilityDetectionAnalyzerComponent> analyzers;
		
	public VulnerabilityDetectionAnalyzer() {

		super("Vulnerability Detection", "Detects various vulnerabilities documented by CWE", AnalyzerType.BYTE_ANALYZER);
		
		analyzers = new LinkedHashSet<VulnerabilityDetectionAnalyzerComponent>();
		analyzers.add(new NullPointerDereferenceAnalyzer());
		analyzers.add(new OutOfBoundsAccessAnalyzer());
		analyzers.add(new BufferOverflowAnalyzer());
		analyzers.add(new UseAfterFreeAnalyzer());
		analyzers.add(new DoubleFreeAnalyzer());
		analyzers.add(new UnsafeLibraryFunctionDetection());
	}

	@Override
	public void analysisEnded(Program program) {
		
		// print results with provider or sumn
		
	}
	
	@Override
	public boolean getDefaultEnablement(Program program) {
		return true;
	}

	@Override
	public boolean canAnalyze(Program program) {
		return true;
	}
	
	Options optionsa;
	
	@Override
	public void registerOptions(Options options, Program program) {

		optionsa = options;
		
		options.registerOption("Prefer false negatives", false, null, "Prefer false negatives over false positives. Opposite if not set.");
		
		for (VulnerabilityDetectionAnalyzerComponent analyzer : analyzers) {
			options.registerOption(analyzer.getString(), true, null, analyzer.getDescription());
		}
	}

	
	@Override
	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {
	
		VulnerabilityDetectionUtils.init(program);

		for (VulnerabilityDetectionAnalyzerComponent analyzer : analyzers) {

			if (!optionsa.getBoolean(analyzer.getString(), false))
				continue;
			
			analyzer.analyze(program, monitor, log, optionsa.getBoolean("Prefer false negatives", false));
		}
		
		for (VulnerabilityDetectionAnalyzerComponent analyzer : analyzers) {

			if (!optionsa.getBoolean(analyzer.getString(), false))
				continue;
			
			log.appendMsg(analyzer.getString());
			printResults(analyzer.getResults(), log);
			log.appendMsg("\n\n");
		}
		
		return true;
	}	
	
	// probably move to AnalyzerComponent to be customizable for different analyzers
	private void printResults(VulnerabilityDetectionResults results, MessageLog log) {
						
		for (HighFunction func : results.getDetectedFunctions()) {
				
			log.appendMsg(func.getFunction().getName());
				
			if (results.getInherentVars(func).size() > 0) {
				log.appendMsg("\tInherent Var");
				for (HighVariable var : results.getInherentVars(func))
					log.appendMsg("\t\t" + var.getName());
			}
				
			if (results.getPotentialVars(func).size() > 0) {
				log.appendMsg("\tPotential Var");
				for (HighVariable var : results.getPotentialVars(func))
					log.appendMsg("\t\t" + var.getName());
			}
							
			if (results.getInherentAddrs(func).size() > 0) {	
				log.appendMsg("\tInherent Addr");
				for (Address addr : results.getInherentAddrs(func))
					log.appendMsg("\t\t" + addr);
			}
			
			if (results.getPotentialAddrs(func).size() > 0) {
				log.appendMsg("\tPotential Addr");
				for (Address addr : results.getPotentialAddrs(func))
					log.appendMsg("\t\t" + addr);
			}
				
			if (results.getUnknownAddrs(func).size() > 0) {
				log.appendMsg("\tUnknown Addr");
				for (Address addr : results.getUnknownAddrs(func))
					log.appendMsg("\t\t" + addr);
			}			
		}
	
		if (results.getInherentNotTiedToVars().size() > 0) {
			log.appendMsg("Inherent");
			for (Function func : results.getInherentNotTiedToVars())
				log.appendMsg("\t\t" + func.getName());
		}
			
		if (results.getPotentialNotTiedToVars().size() > 0) {
			log.appendMsg("Potential");
			for (Function func : results.getPotentialNotTiedToVars())
				log.appendMsg("\t\t" + func.getName());
		}			
	}
}

